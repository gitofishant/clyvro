'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var parser = require('@babel/parser');
var core = require('@babel/core');
var path = require('path');
var MagicString = require('magic-string');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);

const REACT_STRUCTURAL_COMPONENTS = new Set([
    'Fragment',
    'Suspense',
    'StrictMode',
    'Profiler',
    'React.Fragment',
]);
/**
 * Determines if a file should be processed based on its extension and path
 * @param filePath The path of the file to check
 * @param options Plugin options
 * @returns Boolean indicating if the file should be processed
 */
function shouldProcessFile(filePath, options) {
    const extensions = options.extensions || ['.jsx', '.tsx', '.js', '.ts'];
    const ext = path__namespace.extname(filePath);
    const skipPatterns = ['.test.', '.spec.', '__tests__', '__mocks__'];
    const shouldSkip = skipPatterns.some((pattern) => filePath.includes(pattern));
    return extensions.includes(ext) && !shouldSkip;
}
/**
 * Determines if an element should be tagged based on its name and options
 * @param elementName The name of the JSX element
 * @param options Plugin options
 * @returns Boolean indicating if the element should be tagged
 */
function shouldTagElement(elementName, options) {
    if (options.includeElements && options.includeElements.length > 0) {
        return options.includeElements.includes(elementName);
    }
    if (options.shouldTag) {
        return options.shouldTag(elementName);
    }
    if (options.excludeElements &&
        options.excludeElements.includes(elementName)) {
        return false;
    }
    if (REACT_STRUCTURAL_COMPONENTS.has(elementName)) {
        return false;
    }
    return true;
}
/**
 * Safely extracts a string value from a JSX attribute value
 * @param value The attribute value node
 * @returns The extracted string value or undefined
 */
function extractStringValue(value) {
    if (!value)
        return undefined;
    if (value.type === 'StringLiteral') {
        return value.value;
    }
    if (value.type === 'JSXExpressionContainer') {
        const expr = value.expression;
        if (expr.type === 'StringLiteral') {
            return expr.value;
        }
        if (expr.type === 'TemplateLiteral' && expr.quasis.length === 1) {
            return expr.quasis[0].value.raw;
        }
        if (expr.type === 'BinaryExpression' && expr.operator === '+') {
            const left = expr.left.type === 'StringLiteral' ? expr.left.value : '';
            const right = expr.right.type === 'StringLiteral' ? expr.right.value : '';
            return left + right;
        }
        if (expr.type === 'Identifier') {
            return `[var:${expr.name}]`;
        }
    }
    return undefined;
}
/**
 * Extract attributes from JSX opening element
 * @param node The JSX opening element node
 * @param options Plugin options
 * @returns Record of attribute names and values
 */
function extractAttributes(node, options, currentElement) {
    const attributes = {};
    const defaultAttrs = [
        'className',
        'id',
        'src',
        'alt',
        'href',
        'type',
        'name',
        'value',
    ];
    const attrsToExtract = new Set([
        ...defaultAttrs,
        ...(options.extractAttributes || []),
    ]);
    for (const attr of node.attributes) {
        if (attr.type === 'JSXAttribute' && attr.name.type === 'JSXIdentifier') {
            const name = attr.name.name;
            if (!attrsToExtract.has(name))
                continue;
            if (attr.value) {
                const stringValue = extractStringValue(attr.value);
                if (stringValue !== undefined) {
                    attributes[name] = stringValue;
                }
            }
            else {
                attributes[name] = 'true';
            }
        }
        else if (attr.type === 'JSXSpreadAttribute') {
            attributes['[spread]'] = 'true';
        }
    }
    let textContent = '';
    if (currentElement && currentElement.children) {
        textContent = currentElement.children
            .map((child) => {
            if (child.type === 'JSXText') {
                return child.value.trim();
            }
            else if (child.type === 'JSXExpressionContainer') {
                if (child.expression.type === 'StringLiteral') {
                    return child.expression.value;
                }
            }
            return '';
        })
            .filter(Boolean)
            .join(' ')
            .trim();
    }
    if (textContent) {
        attributes['textContent'] = textContent;
    }
    return attributes;
}
/**
 * Get element name from JSX opening element
 * @param jsxNode The JSX opening element node
 * @returns The element name as a string
 */
function getElementName(jsxNode) {
    const name = jsxNode.name;
    if (name.type === 'JSXIdentifier') {
        return name.name;
    }
    if (name.type === 'JSXMemberExpression') {
        // Handle nested expressions like Namespace.Component
        return getMemberExpressionName(name);
    }
    // if (name.type === 'JSXNamespacedName') {
    //   return `${name.namespace.name}:${name.name.name}`;
    // }
    return 'Unknown';
}
/**
 * Recursively builds the full name of a JSX member expression
 * @param expr The JSX member expression
 * @returns The full dotted name
 */
function getMemberExpressionName(expr) {
    // const propertyName = expr.property.name;
    /*
    else if (jsxNode.name.type === "JSXMemberExpression") {
                              const memberExpr = jsxNode.name;
                              elementName = `${(memberExpr.object as JSXIdentifier).name}.${(memberExpr.property as JSXIdentifier).name}`;
                          } */
    // if (expr.object.type === 'JSXMemberExpression') {
    //   return `${expr.object as JSXIdentifier}`
    //   return `${getMemberExpressionName(expr.object)}.${propertyName}`;
    // }
    // if (expr.object.type === 'JSXIdentifier') {
    //   return `${expr.object.name}.${propertyName}`;
    // }
    const propertyName = `${expr.object.name}.${expr.property.name}`;
    return propertyName;
}
/**
 * Sanitizes a string for use in HTML attributes
 * @param str The string to sanitize
 * @returns The sanitized string
 */
function sanitizeAttributeValue(str) {
    return str
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}
/**
 * Creates a unique component ID based on file path and location
 * @param filePath The relative file path
 * @param line The line number
 * @param column The column number
 * @returns A unique component ID string
 */
function createComponentId(filePath, line, column) {
    return `${filePath}:${line}:${column}`;
}
/**
 * Logs a message if verbose mode is enabled
 * @param message The message to log
 * @param options Plugin options
 */
function verboseLog(message, options) {
    if (options.verbose) {
        // eslint-disable-next-line no-console
        console.log(`[component-tagger] ${message}`);
    }
}

/**
 * Custom JSX Loader that adds tracking attributes to JSX elements
 * @param this - The webpack loader context
 * @param source - The source code to transform
 * @returns The transformed source code
 */
function webPackLoader(source) {
    // Get the current file path
    const filePath = this.resourcePath;
    const projectRoot = process.cwd();
    const relativePath = path__namespace.relative(projectRoot, filePath);
    const fileName = path__namespace.basename(filePath);
    // Get options from loader query or use defaults
    const options = {
        extensions: ['.jsx', '.tsx', '.js', '.ts'],
        verbose: false,
        attributePrefix: 'data-component',
        includeContentAttribute: true,
        maxContentLength: 1000,
        includeLegacyAttributes: true,
        sourceMaps: true,
        excludeDirectories: [],
        processNodeModules: false,
        ...this.query,
    };
    // Skip files that shouldn't be processed
    if (!shouldProcessFile(filePath, options)) {
        return source;
    }
    if (filePath.includes('node_modules') && !options.processNodeModules) {
        return source;
    }
    if (options.excludeDirectories &&
        options.excludeDirectories.some((dir) => filePath.includes(dir))) {
        return source;
    }
    verboseLog(`Processing file: ${relativePath}`, options);
    try {
        const ast = parser.parse(source, {
            sourceType: 'module',
            plugins: ['jsx', 'typescript'],
        });
        const magicString = new MagicString(source);
        let changedElementsCount = 0;
        let currentElement = null;
        core.traverse(ast, {
            JSXElement(nodePath) {
                currentElement = nodePath.node;
            },
            JSXOpeningElement(nodePath) {
                var _a, _b, _c, _d, _e, _f, _g;
                if (!currentElement)
                    return;
                const jsxNode = nodePath.node;
                const elementName = getElementName(jsxNode);
                if (!shouldTagElement(elementName, options)) {
                    return;
                }
                const jsxAttributes = extractAttributes(jsxNode, options, currentElement);
                const content = { elementName };
                Object.entries(jsxAttributes).forEach(([key, value]) => {
                    Object.assign(content, { [key]: value });
                });
                const line = (_c = (_b = (_a = jsxNode.loc) === null || _a === void 0 ? void 0 : _a.start) === null || _b === void 0 ? void 0 : _b.line) !== null && _c !== void 0 ? _c : 0;
                const col = (_f = (_e = (_d = jsxNode.loc) === null || _d === void 0 ? void 0 : _d.start) === null || _e === void 0 ? void 0 : _e.column) !== null && _f !== void 0 ? _f : 0;
                const dataComponentId = options.generateComponentId
                    ? options.generateComponentId(relativePath, line, col)
                    : createComponentId(relativePath, line, col);
                let attributesToAdd = ` ${options.attributePrefix}-id="${sanitizeAttributeValue(dataComponentId)}"`;
                if (options.includeLegacyAttributes) {
                    attributesToAdd += ` ${options.attributePrefix}-path="${sanitizeAttributeValue(relativePath)}"`;
                    attributesToAdd += ` ${options.attributePrefix}-line="${line}"`;
                    attributesToAdd += ` ${options.attributePrefix}-file="${sanitizeAttributeValue(fileName)}"`;
                    attributesToAdd += ` ${options.attributePrefix}-name="${sanitizeAttributeValue(elementName)}"`;
                }
                if (options.includeContentAttribute) {
                    const contentJson = JSON.stringify(content);
                    let encodedContent = encodeURIComponent(contentJson);
                    if (options.maxContentLength &&
                        encodedContent.length > options.maxContentLength) {
                        encodedContent =
                            encodedContent.substring(0, options.maxContentLength) + '...';
                    }
                    attributesToAdd += ` ${options.attributePrefix}-content="${encodedContent}"`;
                }
                // Add attributes to the node
                const nameEnd = (_g = jsxNode.name.end) !== null && _g !== void 0 ? _g : 0;
                magicString.appendLeft(nameEnd, attributesToAdd);
                verboseLog(attributesToAdd.toString(), options);
                changedElementsCount++;
            },
        });
        if (changedElementsCount > 0) {
            verboseLog(`Tagged ${changedElementsCount} components in ${relativePath}`, options);
            return magicString.toString();
        }
        return source;
    }
    catch (error) {
        verboseLog('Error in component-tagger loader:', options);
        verboseLog('File path:', options);
        if (error instanceof Error) {
            verboseLog('Error details:', options);
        }
        // Return original source on error to prevent build failures
        return source;
    }
}

exports.default = webPackLoader;
//# sourceMappingURL=nextLoader.js.map
